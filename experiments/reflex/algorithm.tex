\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{geometry}

\geometry{margin=1in}

\title{Reflex-Aware Polygon Triangulation:\\A Practical Algorithm with Spatial Hashing}
\author{Research Report}
\date{\today}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}

\begin{document}

\maketitle

\begin{abstract}
We present a practical polygon triangulation algorithm that combines ear clipping with spatial hashing and reflex-vertex awareness. The algorithm achieves $O(n)$ time for convex polygons and $O(n \cdot k)$ expected time for non-convex polygons, where $k$ is the average number of reflex vertices per spatial hash query. While the worst-case complexity remains $O(n^2)$, our implementation demonstrates significant speedups over the highly-optimized Mapbox Earcut library on many polygon types, particularly those with few or spatially-clustered reflex vertices. We present rigorous benchmarks on polygons up to 100,000 vertices.
\end{abstract}

\section{Introduction}

Polygon triangulation is a fundamental problem in computational geometry. Given a simple polygon $P$ with $n$ vertices, the goal is to partition its interior into $n-2$ non-overlapping triangles.

\subsection{Theoretical Background}

The complexity landscape of polygon triangulation:
\begin{itemize}
    \item \textbf{Ear Clipping} \cite{meisters1975}: $O(n^2)$ worst-case, simple to implement
    \item \textbf{Garey et al.} \cite{garey1978}: $O(n \log n)$ via monotone decomposition
    \item \textbf{Hertel-Mehlhorn} \cite{hertel1985}: $O(n + r \log r)$ where $r$ is reflex count
    \item \textbf{Chazelle} \cite{chazelle1991}: Optimal $O(n)$ deterministic (complex)
\end{itemize}

\subsection{Our Contribution}

We present a practical algorithm that:
\begin{enumerate}
    \item Uses \textbf{fan triangulation} for convex polygons: $O(n)$
    \item Uses \textbf{spatial hashing} to accelerate point-in-triangle tests
    \item Only checks \textbf{reflex vertices} for ear validation
    \item Achieves significant practical speedups on many polygon types
\end{enumerate}

\section{Algorithm Description}

\subsection{Definitions}

\begin{definition}[Reflex Vertex]
A vertex $v_i$ is \emph{reflex} if its interior angle exceeds $180^\circ$.
\end{definition}

\begin{definition}[Ear]
A vertex $v_i$ forms an \emph{ear} if it is convex and no other polygon vertex lies inside the triangle $(v_{i-1}, v_i, v_{i+1})$.
\end{definition}

\begin{lemma}
Only reflex vertices can lie inside an ear triangle.
\end{lemma}

\begin{proof}
A convex vertex $v_j$ cannot be inside the triangle $(v_{i-1}, v_i, v_{i+1})$ because the polygon boundary would have to cross itself, contradicting simplicity.
\end{proof}

\subsection{Algorithm Overview}

\begin{algorithm}[H]
\caption{Reflex-Aware Triangulation}
\begin{algorithmic}[1]
\Procedure{Triangulate}{$P = (v_0, \ldots, v_{n-1})$}
    \State $R \gets$ \Call{FindReflexVertices}{$P$}
    \If{$R = \emptyset$} \Comment{Convex polygon}
        \State \Return \Call{FanTriangulate}{$P$} \Comment{$O(n)$}
    \EndIf
    \State $H \gets$ \Call{BuildSpatialHash}{$R$}
    \State $L \gets$ doubly-linked list of vertices
    \While{$|L| > 3$}
        \For{each vertex $v$ in $L$}
            \If{\Call{IsEar}{$v, R, H$}}
                \State Output triangle $(v.\text{prev}, v, v.\text{next})$
                \State Remove $v$ from $L$
                \State Update $R$ and $H$ for neighbors
                \State \textbf{break}
            \EndIf
        \EndFor
    \EndWhile
    \State Output final triangle
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Spatial Hash Optimization}

The key optimization is using a spatial hash to quickly find reflex vertices near an ear candidate:

\begin{algorithm}[H]
\caption{Ear Test with Spatial Hash}
\begin{algorithmic}[1]
\Function{IsEar}{$v, R, H$}
    \If{$v$ is not convex} \Return false \EndIf
    \State $B \gets$ bounding box of triangle $(v.\text{prev}, v, v.\text{next})$
    \For{each reflex vertex $r$ in $H.\text{query}(B)$}
        \If{$r \in$ triangle} \Return false \EndIf
    \EndFor
    \State \Return true
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Complexity Analysis}

\begin{theorem}[Convex Case]
For convex polygons ($r = 0$), the algorithm runs in $O(n)$ time.
\end{theorem}

\begin{proof}
Fan triangulation outputs $n-2$ triangles in a single pass.
\end{proof}

\begin{theorem}[General Case]
For non-convex polygons, the worst-case complexity is $O(n^2)$.
\end{theorem}

\begin{proof}
In the worst case:
\begin{itemize}
    \item We must remove $n-2$ ears
    \item Each ear search may scan $O(n)$ vertices
    \item Each ear test may check $O(r)$ reflex vertices
\end{itemize}
Total: $O(n \cdot (n + r)) = O(n^2)$ since $r \leq n/2$.
\end{proof}

\begin{remark}[Expected Complexity]
With spatial hashing and well-distributed vertices, the expected complexity is $O(n \cdot k)$ where $k$ is the average number of reflex vertices per hash cell query. For uniformly distributed polygons, $k = O(1)$ on average, giving $O(n)$ expected time.
\end{remark}

\section{Experimental Results}

We benchmark against Mapbox Earcut, a highly-optimized industrial implementation.

\subsection{Test Setup}
\begin{itemize}
    \item Polygon types: convex, random, star, spiral
    \item Sizes: 100 to 100,000 vertices
    \item Platform: Linux (WSL), GCC with -O3
\end{itemize}

\subsection{Results}

\input{results_table}

\subsection{Key Observations}

\begin{enumerate}
    \item \textbf{Convex polygons}: Our algorithm is 5-6x faster than Earcut due to the $O(n)$ fan triangulation fast path.
    
    \item \textbf{Star polygons} (high reflex ratio $r/n \approx 0.5$): Competitive performance, with our algorithm faster at larger sizes due to spatial hashing benefits.
    
    \item \textbf{Random polygons}: Similar performance to Earcut, both showing near-quadratic scaling for high-reflex cases.
    
    \item \textbf{Spiral polygons}: Earcut is faster because our ear-clipping loop has higher overhead when $r$ is small but non-zero.
\end{enumerate}

\subsection{Performance Visualization}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{figures/figure1_performance.png}
    \caption{Performance comparison: (a) by polygon type, (b) average across all types.}
    \label{fig:performance}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/figure2_triangulation.png}
    \caption{Triangulation comparison on 500-vertex polygons.}
    \label{fig:triangulation}
\end{figure}

\section{Discussion}

\subsection{When to Use This Algorithm}

Our algorithm is recommended when:
\begin{itemize}
    \item Polygons are frequently convex or nearly convex
    \item Reflex vertices are spatially clustered
    \item Simplicity of implementation is valued
\end{itemize}

Earcut is recommended when:
\begin{itemize}
    \item Polygons have many scattered reflex vertices
    \item Consistent performance across all input types is required
    \item Memory efficiency is critical
\end{itemize}

\subsection{Achieving True $O(n + r \log r)$}

To achieve the theoretical $O(n + r \log r)$ complexity of Hertel-Mehlhorn:
\begin{enumerate}
    \item Sort reflex vertices by $y$-coordinate: $O(r \log r)$
    \item Build horizontal chords via plane sweep: $O(n)$
    \item Decompose into $y$-monotone regions: $O(n)$
    \item Triangulate each monotone region: $O(n)$ total
\end{enumerate}

This requires more complex data structures (e.g., balanced BST for active edges) and is left for future work.

\section{Conclusion}

We presented a practical polygon triangulation algorithm that combines ear clipping with spatial hashing and reflex-vertex awareness. While the worst-case complexity is $O(n^2)$, the algorithm achieves significant speedups on convex and low-reflex polygons. Our benchmarks on up to 100,000 vertices demonstrate that the algorithm is competitive with industrial implementations and superior for specific polygon classes.

\bibliographystyle{plain}
\begin{thebibliography}{10}

\bibitem{chazelle1991}
B.~Chazelle.
\newblock Triangulating a simple polygon in linear time.
\newblock {\em Discrete \& Computational Geometry}, 6(5):485--524, 1991.

\bibitem{garey1978}
M.~R. Garey, D.~S. Johnson, F.~P. Preparata, and R.~E. Tarjan.
\newblock Triangulating a simple polygon.
\newblock {\em Information Processing Letters}, 7(4):175--179, 1978.

\bibitem{hertel1985}
S.~Hertel and K.~Mehlhorn.
\newblock Fast triangulation of the plane with respect to simple polygons.
\newblock {\em Information and Control}, 64(1--3):52--76, 1985.

\bibitem{meisters1975}
G.~H. Meisters.
\newblock Polygons have ears.
\newblock {\em The American Mathematical Monthly}, 82(6):648--651, 1975.

\end{thebibliography}

\end{document}
