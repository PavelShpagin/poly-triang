\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{geometry}

\geometry{margin=1in}

\title{Linear-Time Polygon Triangulation\\via Finger Trees and Geometric Locality}
\author{}
\date{}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\begin{document}

\maketitle

\begin{abstract}
We investigate whether polygon triangulation can be achieved in $O(n)$ time using finger trees that exploit geometric locality. The key insight is that consecutive events in the plane sweep (when processed in appropriate order) access nearby locations in the status structure. If the total ``finger distance'' across all operations is $O(n)$, we achieve linear time. We analyze when this locality property holds and identify the conditions under which the approach succeeds.
\end{abstract}

\section{Introduction}

The standard plane sweep for polygon triangulation uses a balanced BST for the status structure, giving $O(\log n)$ per operation. We propose replacing the BST with a \emph{finger tree}---a data structure that provides $O(1)$ amortized access near a maintained ``finger'' position.

\section{Finger Trees}

\begin{definition}[Finger Tree]
A \emph{finger tree} is a balanced tree augmented with a ``finger'' pointer to a recently accessed element. Operations near the finger take $O(\log d)$ time where $d$ is the distance from the finger to the target.
\end{definition}

\begin{lemma}[Finger Tree Bounds]
For a sequence of $m$ operations with finger distances $d_1, d_2, \ldots, d_m$:
\[
\text{Total time} = O\left(\sum_{i=1}^m \log(d_i + 1)\right)
\]
\end{lemma}

\begin{corollary}
If $\sum d_i = O(n)$, then total time is $O(n)$ (since $\log$ is concave, Jensen's inequality gives $\sum \log d_i \leq m \log(n/m)$, and for $m = \Theta(n)$ events, this is $O(n)$).
\end{corollary}

\section{Geometric Locality in Polygon Sweep}

\begin{definition}[Sweep Distance]
For two consecutive sweep events at vertices $v_i$ and $v_j$, the \emph{sweep distance} is the number of edges in the status that lie between the horizontal positions of $v_i$ and $v_j$.
\end{definition}

\begin{lemma}[Locality Lemma]\label{lem:locality}
If vertices are processed in boundary order (not $y$-order), consecutive events have sweep distance $O(1)$.
\end{lemma}

\begin{proof}
Consecutive vertices on the polygon boundary are connected by an edge. In the status structure, this edge either:
\begin{enumerate}
    \item Enters the status (if the edge goes downward from the current vertex)
    \item Leaves the status (if the edge arrives from below)
    \item Is already in the status and adjacent to the finger
\end{enumerate}
In all cases, the new operation is within $O(1)$ of the previous finger position.
\end{proof}

\textbf{PROBLEM}: Processing in boundary order violates the sweep line invariant!

The plane sweep requires processing vertices in $y$-order to maintain the invariant that the status contains exactly the edges intersecting the current sweep line.

\section{Hybrid Approach}

\textbf{Idea}: Process vertices in $y$-order, but use boundary structure to predict finger movement.

\begin{definition}[Boundary Distance]
For two vertices $v_i$ and $v_j$, their \emph{boundary distance} $\text{bd}(v_i, v_j)$ is the minimum number of edges on the polygon boundary between them.
\end{definition}

\begin{lemma}[Status-Boundary Relationship]
If $v_i$ and $v_j$ are consecutive in $y$-order, then the sweep distance is at most:
\[
\text{sweep\_dist}(v_i, v_j) \leq \text{bd}(v_i, v_j)
\]
\end{lemma}

\begin{proof}
The edges in the status between positions of $v_i$ and $v_j$ must cross the horizontal strip between their $y$-coordinates. Each such edge corresponds to a portion of the boundary. The boundary path from $v_i$ to $v_j$ contains at least one endpoint of each crossing edge.
\end{proof}

\begin{theorem}[Total Sweep Distance]
For a simple polygon with $n$ vertices:
\[
\sum_{\text{consecutive } (v_i, v_j)} \text{sweep\_dist}(v_i, v_j) = O(n)
\]
\end{theorem}

\begin{proof}
This is NOT generally true!

\textbf{Counterexample}: Consider a ``zigzag'' polygon where vertices alternate between the top and bottom of the bounding box. Consecutive vertices in $y$-order might be far apart on the boundary.

Specifically: if $v_1, v_2, \ldots, v_n$ are in boundary order, but $y$-order is $v_1, v_3, v_5, \ldots, v_n, \ldots, v_6, v_4, v_2$, then consecutive pairs in $y$-order have boundary distance $\Omega(n)$.

With $n$ such pairs, total is $\Omega(n^2)$... No wait, each vertex appears once, so the sum is at most $O(n \cdot \max \text{bd}) = O(n^2)$ in worst case.
\end{proof}

\section{Refined Analysis: Reflex-Based Locality}

\begin{observation}
The expensive operations in the sweep occur at reflex vertices (split and merge types). Convex vertices perform only local updates.
\end{observation}

\begin{definition}[Reflex Distance]
For consecutive reflex vertices $r_i$ and $r_j$ in the sweep order, the \emph{reflex distance} is the sweep distance between them.
\end{definition}

\begin{lemma}[Reflex Locality Bound]
\[
\sum_{\text{consecutive reflex } (r_i, r_j)} \text{reflex\_dist}(r_i, r_j) = O(n)
\]
\end{lemma}

\begin{proof}[Proof Attempt]
Between consecutive reflex vertices in $y$-order, all intermediate vertices are convex. The boundary path connecting $r_i$ and $r_j$ consists of these convex vertices plus the reflex vertices themselves.

The key insight: each convex vertex on this path ``contributes'' to the distance once. Summing over all pairs, each convex vertex is counted at most twice (once for the pair below, once for the pair above).

Total: $O(n)$.
\end{proof}

\textbf{ISSUE}: The proof assumes consecutive reflex vertices have convex vertices between them on the BOUNDARY, not just in $y$-order. This conflates two different orderings.

\section{Alternative: Two-Finger Approach}

Maintain two fingers:
\begin{itemize}
    \item \textbf{Left finger}: Tracks leftmost active edge
    \item \textbf{Right finger}: Tracks rightmost active edge
\end{itemize}

\begin{algorithm}[H]
\caption{Two-Finger Sweep}
\begin{algorithmic}[1]
\Procedure{TwoFingerSweep}{$P$}
    \State Sort vertices by $y$ \Comment{O(n log n) --- can we avoid?}
    \State Initialize status with two fingers at boundaries
    \For{each vertex $v$ in $y$-order}
        \If{$v$ is leftmost or rightmost in current status}
            \State Access via appropriate finger: $O(1)$
        \Else
            \State Access via closest finger: $O(\log d)$ where $d$ = dist to closest finger
        \EndIf
        \State Update fingers if $v$ becomes new boundary
    \EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{lemma}[Two-Finger Bound]
With two fingers at the left and right boundaries, internal queries cost $O(\log w)$ where $w$ is the current status width.
\end{lemma}

For a polygon with $O(r)$ reflex vertices active at any time, $w = O(r)$, giving $O(\log r)$ per internal query.

This recovers $O(n + r \log r)$ but not $O(n)$.

\section{Conclusion: Finger Trees Insufficient}

After careful analysis, the finger tree approach faces fundamental obstacles:

\begin{enumerate}
    \item \textbf{Ordering conflict}: Boundary order gives locality but violates sweep correctness. $Y$-order is correct but doesn't guarantee locality.
    
    \item \textbf{Worst-case counterexamples}: Zigzag polygons have $\Theta(n^2)$ total sweep distance when processed in $y$-order.
    
    \item \textbf{Best achievable}: Two-finger approach gives $O(n + r \log r)$, matching our existing bound.
\end{enumerate}

\textbf{VERDICT}: Finger trees alone do not achieve $O(n)$ for general polygons. The approach might work for restricted polygon classes (e.g., bounded ``zigzag depth'').

\section{Possible Salvage: Process Boundary Order with Deferred Diagonals}

\textbf{New Idea}: Process vertices in boundary order (for locality), but defer diagonal insertion until we have enough information.

\begin{algorithm}[H]
\caption{Boundary-Order Processing}
\begin{algorithmic}[1]
\Procedure{BoundaryProcess}{$P$}
    \State \Comment{Pass 1: Collect structure information}
    \For{each vertex $v$ in boundary order}
        \State Classify $v$ (start/end/split/merge/regular)
        \State Record $v$'s position relative to current ``horizon''
    \EndFor
    \State
    \State \Comment{Pass 2: Insert diagonals}
    \State Use collected information to insert diagonals
\EndProcedure
\end{algorithmic}
\end{algorithm}

This deferred approach might avoid the ordering conflict, but needs careful development.

\textbf{STATUS: PROMISING BUT INCOMPLETE}

\end{document}

