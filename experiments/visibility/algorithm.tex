\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{booktabs}
\usepackage{geometry}

\geometry{margin=1in}

\title{Polygon Triangulation via Horizontal Chords\\in $O(n + r\log r)$ Deterministic Time}
\author{Research Report}
\date{\today}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}

\begin{document}

\maketitle

\begin{abstract}
We present a deterministic $O(n + r\log r)$ algorithm for triangulating simple polygons, where $n$ is the number of vertices and $r$ is the number of monotonicity-violating reflex vertices. The algorithm adds horizontal chords through each such reflex vertex, decomposing the polygon into $y$-monotone regions. The key contribution is a careful analysis showing that by processing reflex vertices in $y$-sorted order and maintaining the polygon as a shrinking doubly-linked list, each edge is traversed at most once during chord construction. For integer coordinates, using radix sort yields $O(n)$ total time.
\end{abstract}

\section{Definitions}

\begin{definition}
A vertex $v$ of a CCW simple polygon is:
\begin{itemize}
    \item \textbf{Reflex}: if its interior angle exceeds $180Â°$
    \item \textbf{Upward-violating}: if reflex with both neighbors strictly above ($y > y(v)$)
    \item \textbf{Downward-violating}: if reflex with both neighbors strictly below
\end{itemize}
\end{definition}

Let $R = R_\uparrow \cup R_\downarrow$ with $|R| = r \leq n/2$.

\begin{definition}
The \textbf{horizontal chord} $H(v)$ through $v \in R$ is the maximal horizontal segment at height $y(v)$ contained in the polygon. Its endpoints lie on the \textbf{left support edge} $e_L(v)$ and \textbf{right support edge} $e_R(v)$.
\end{definition}

\section{Non-Intersection Theorem}

\begin{theorem}
Horizontal chords from distinct reflex vertices do not cross.
\end{theorem}

\begin{proof}
Chords at different heights are parallel. At the same height, they lie in disjoint horizontal segments of the polygon's intersection with that line.
\end{proof}

\section{Algorithm}

\begin{algorithm}[H]
\caption{Triangulation via Horizontal Chords}
\begin{algorithmic}[1]
\Procedure{Triangulate}{$P$}
    \State Build doubly-linked list $L$ from $P$ \Comment{$O(n)$}
    \State Find $R_\uparrow, R_\downarrow$; sort by $y$ \Comment{$O(n + r\log r)$}
    \State
    \For{$v \in R_\uparrow$ in ascending $y$-order}
        \State $e_L, p_L \gets$ \Call{FindLeftSupport}{$v, L$}
        \State $e_R, p_R \gets$ \Call{FindRightSupport}{$v, L$}
        \State \Call{SpliceValley}{$L, v, p_L, p_R$}
    \EndFor
    \State
    \For{$v \in R_\downarrow$ in descending $y$-order}
        \State $e_L, p_L \gets$ \Call{FindLeftSupport}{$v, L$}
        \State $e_R, p_R \gets$ \Call{FindRightSupport}{$v, L$}
        \State \Call{SplicePeak}{$L, v, p_L, p_R$}
    \EndFor
    \State
    \For{each region in decomposition}
        \State \Call{TriangulateMonotone}{region}
    \EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Key Operation: Splicing}

When processing upward reflex vertex $v$ at height $y^*$:

\begin{enumerate}
    \item Walk from $v.\text{prev}$ backward to find $e_L$ crossing $y^*$
    \item Walk from $v.\text{next}$ forward to find $e_R$ crossing $y^*$
    \item Create chord endpoints $p_L, p_R$ on these edges
    \item \textbf{Valley}: Close cycle through $p_L \to (\text{below } y^*) \to v \to (\text{below } y^*) \to p_R$
    \item \textbf{Remaining}: Update $L$ to bypass the valley: $\cdots \to p_L' \to p_R' \to \cdots$
\end{enumerate}

\textbf{Critical}: The valley is \textbf{removed} from $L$. Future walks use the updated, shorter list.

\section{Complexity Analysis}

\begin{theorem}[Main Result]
The algorithm runs in $O(n + r\log r)$ time.
\end{theorem}

\begin{proof}
We prove that the total edge traversals in all \textsc{FindSupport} calls is $O(n)$.

\textbf{Potential function argument}: Let $\Phi = $ number of edges in $L$.

Initially $\Phi_0 = n$. When processing $v$:
\begin{itemize}
    \item Let $k$ = edges traversed to find supports
    \item After splicing, the valley (with $\geq k - O(1)$ edges) is removed from $L$
    \item New edges added: $O(1)$ (chord edges)
\end{itemize}

Amortized cost $= k + \Delta\Phi = k - (k - O(1)) + O(1) = O(1)$.

Total over all $r$ vertices: $O(r)$ amortized.

Actual total $= O(r) + \Phi_0 - \Phi_{\text{final}} \leq O(r) + n = O(n)$.

Adding sorting: $O(n + r\log r)$.
\end{proof}

\begin{lemma}[Traversed Edges Are Removed]
The edges traversed during \textsc{FindLeftSupport} and \textsc{FindRightSupport} are all contained in the spliced-out valley.
\end{lemma}

\begin{proof}
For upward reflex $v$ at height $y^*$:
\begin{itemize}
    \item Walking from $v.\text{prev}$ (above $y^*$), we follow the boundary that descends toward and past $y^*$
    \item The traversed edges connect vertices that eventually dip below $y^*$
    \item The support edge is where the boundary crosses back through $y^*$
    \item Everything between $v$ and the support edges (in boundary order) is in the valley
\end{itemize}
Thus all traversed edges are in the valley and are removed from $L$.
\end{proof}

\section{Special Case: $O(n)$ for Integer Coordinates}

\begin{corollary}
For integer coordinates in $[0, n^{O(1)}]$, the algorithm runs in $O(n)$ time.
\end{corollary}

\begin{proof}
Replace comparison sort with radix sort. Sorting $r$ integers in range $[0, n^c]$ takes $O(r \cdot c) = O(r)$ time. All other phases are $O(n)$.
\end{proof}

\section{Correctness}

\begin{theorem}
The algorithm produces a valid triangulation.
\end{theorem}

\begin{proof}
\begin{enumerate}
    \item \textbf{Chords are valid}: Horizontal segments through interior points, ending at boundary.
    \item \textbf{Chords don't cross}: By the non-intersection theorem.
    \item \textbf{Regions are $y$-monotone}: Each region has its violating reflex vertex removed.
    \item \textbf{Triangulation correct}: Standard monotone triangulation applies.
\end{enumerate}
\end{proof}

\section{Comparison}

\begin{center}
\begin{tabular}{lll}
\toprule
\textbf{Algorithm} & \textbf{Time} & \textbf{Notes} \\
\midrule
Ear Clipping & $O(n^2)$ & Simple \\
Garey et al.\ 1978 & $O(n\log n)$ & Sweep line \\
Hertel-Mehlhorn 1985 & $O(n + r\log r)$ & Trapezoid chains \\
This paper & $O(n + r\log r)$ & Horizontal chords \\
Chazelle 1991 & $O(n)$ & Complex \\
\bottomrule
\end{tabular}
\end{center}

\section{Conclusion}

We have presented a clean $O(n + r\log r)$ polygon triangulation algorithm based on:
\begin{enumerate}
    \item Adding horizontal chords through monotonicity-violating reflex vertices
    \item Processing in $y$-sorted order
    \item Maintaining a shrinking linked-list representation
    \item Amortized analysis via potential functions
\end{enumerate}

The algorithm achieves $O(n)$ for integer coordinates and is significantly simpler than Chazelle's linear-time algorithm.

\begin{thebibliography}{99}
\bibitem{hertel1985} S.~Hertel, K.~Mehlhorn. Fast triangulation of simple polygons. \emph{Inf.\ Control}, 64:52--76, 1985.
\bibitem{garey1978} M.~Garey et al. Triangulating a simple polygon. \emph{IPL}, 7(4):175--179, 1978.
\bibitem{chazelle1991} B.~Chazelle. Triangulating a simple polygon in linear time. \emph{DCG}, 6:485--524, 1991.
\end{thebibliography}

\end{document}
