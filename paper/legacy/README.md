# O(n + k log k) Polygon Triangulation (specializes to O(n + r log r))

Paper and benchmark code for chain-based monotone decomposition polygon triangulation.

## Algorithm Summary

Triangulates a simple polygon with **n vertices** in **O(n + k log k)** time, where **k** is the number of local extrema (local maxima / minima) with respect to the sweep direction.

Under the (claimed) extrema bound \(k \le r + 1\), this specializes to **O(n + r log r)**, where **r** is the number of reflex vertices.

| Polygon Type | r | Complexity | vs O(n log n) |
|--------------|---|------------|---------------|
| Convex | 0 | O(n) | 5-8x faster |
| Low-reflex | O(1) | O(n) | 5-6x faster |
| Random | ~n/2 | O(n log n) | comparable |
| Star | n/2 | O(n log n) | comparable |

## Quick Start

```bash
# Build
mkdir -p build && cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
make -j reflex_cli polypartition_mono_cli seidel_cli

# Run benchmark
cd ..
python3 paper/benchmark.py --sizes 100 500 1000 2000 5000 10000 --polygons-per-config 5
```

## Directory Structure

```
paper/
├── submission.tex         # Paper (LaTeX submission)
├── README.md              # This file
├── baselines/             # Baseline implementations (polypartition, Seidel, etc.)
├── generated/             # Auto-generated LaTeX tables used by submission.tex
└── benchmark.py           # Paper benchmark harness (writes results.txt + generated/*.tex)
```

## Reproducing Results

### Paper Benchmark (authoritative for `submission.tex`)

```bash
python3 paper/benchmark.py --sizes 100 500 1000 2000 5000 10000 --polygons-per-config 5
```

Output:
- `paper/results.txt`: Human-readable table
- `paper/generated/benchmark_table.tex`: Random-only table included by the paper
- `paper/generated/benchmark_full.tex`: Full table included by the paper

### Manual Testing

```bash
# Build
cd build && cmake -DCMAKE_BUILD_TYPE=Release .. && make -j

# Run our algorithm
./bin/reflex_cli --input polygon.poly --output out.tri
# Output: CSV-like key-value line including: triangles, expected, reflex_count, time_ms

# Run baselines
./bin/polypartition_mono_cli --input polygon.poly --output out.tri  # Garey O(n log n)
./bin/polypartition_hm_cli --input polygon.poly --output out.tri    # Hertel--Mehlhorn
./bin/seidel_cli --input polygon.poly --output out.tri              # Seidel O(n log* n)
```

### Polygon File Format

```
N                    # vertex count
x0 y0                # vertex 0 (CCW order)
x1 y1                # vertex 1
...
```

## Implementation

Core implementation used by `reflex_cli`:

- `methods/include/reflex_chain_triangulate.hpp`: chain-based sweep (output-sensitive in \(k\))
- `methods/include/reflex_fast_linked.hpp`: edge-based linked sweep (fallback for high-reflex inputs)
- `methods/src/reflex_cli.cpp`: hybrid selection (chains for low-r, linked for high-r)

```
Phase 1: Classify vertices, build chains     O(n)
Phase 2: Sweep with O(k) events              O(k log k)
         Lazy chain advancement              O(n) amortized
Phase 3: Triangulate monotone faces          O(n)
─────────────────────────────────────────────────────────
TOTAL                                        O(n + k log k)   (and O(n + r log r) under k = O(r))
```

## Verify Correctness

```bash
python3 test_fast.py
# All tests should show "OK" with triangle count = n - 2
```

## Compile Paper

```bash
cd paper
pdflatex submission.tex
pdflatex submission.tex
```

## Benchmark Results Summary

See `paper/results.txt` (generated by `paper/benchmark.py`).

## Citation

```bibtex
@article{shpagin2025triangulation,
  title={Practical polygon triangulation in {$O(n + r\log r)$} time},
  author={Shpagin, Pavel and Tereschenko, Vasyl},
  year={2025}
}
```

