Науково-практичний звіт на тему 
РЕФЛЕКСІЙНА ПОЛІГОНАЛЬНА ТРИАНГУЛЯЦІЯ 
П. А. Шпагін, студент 3 курсу, групи МІ 
Анотація. В роботі наведено детальний огляд класичних алгоритмів триангуляції простого полігона (Від O(N²) до O(N)) і запропоновано новий простий алгоритм з часом r log r + O(N), де r - кількість рефлексних вершин. Новий метод поєднує пошук рефлексних вершин, прокладання горизонтальних хорд і лінійну триангуляцію y-монотонних підрозділів. Такий алгоритм зменшує константний множник перед N log N більш ніж в 3 рази за кращі поточні O(N log N) алгоритми триангулювання. Також, цей метод має перспективу у спрощенні та пришвидшенні алгоритму Chazelle. 
Abstract. The paper provides a detailed review of classical algorithms for triangulation of a simple polygon (From O(N²) to O(N)) and proposes a new simple algorithm with time r log r + O(N), where r is the number of reflex vertices. The new method combines the search for reflex vertices, laying horizontal chords and linear triangulation of y-monotone subdivisions. Such algorithm improves the constant factor before N log N by more than 3 times over the best current O(N log N) triangulation algorithms. Also, this method has the potential to simplify and speed up the Chazelle algorithm. 
1 Вступ 
Постановка проблеми. В роботі проводиться детальний огляд найпрактичніших, найпростіших та найперспективніших алгоритмів триангуляції простих полігонів та пропонується новий простий найшвидший O(N log N) алгоритм триангуляції, що виконується за час r log r + O(N), де r - кількість рефлексних вершин, r <= N/2 . Цей алгоритм є корисним не тільки із практичної точки зору, а й з теоретичної, бо ідеї можуть бути використані для спрощення та пришвидшення найкращого існуючого на поточний момент детермінованого лінійного алгоритму полігональної триангуляції Чазеле [1]. Варто зазначити, що сама задача є однією із найперших в комп’ютерній графіці, яка має широке застосування в рендерингу, навігації, робототехніці та інших сферах комп’ютерної графіки. 
Аналіз останніх досліджень. Одним із найперших та найпростіших запропонованих алгоритмів триангуляції є так званий “ear-clipping” [2], що працює знаходячи діагоналі за час O(N) та розділяючи полігон на дві частини, даючи загальний час O(N²) . Першим кращим методом був Гарей [3], що має часову складність O(N logN) та базується на регуляризації простого полігону, і подальшої лінійної триангуляції її y-монотонних частин за допомогою використання стека. Також були запропоновані інші версії цього алгоритму, що розбивають полігон на y-монотонні частини за допомогою проведення діагоналей між точками, що мають внутрішній кут >= 180 [4] та методом розділяй-та-володарюй, із детальним оглядом всіх частинних випадків при злитті [5]. Близьким до лінійного, був запропонований метод Гертеля [6], що дає час O(N + r log r), де r - кількість рефлексних вершин. Слідуючи цьому відкриттю, Таржан [7] запропонував прискорення до O(N log log N), який був надалі концептуально спрощений роботою Кірпатік [8]. Подальші прискорення були рандомізовані, а саме до часу O(N log* N), де log*N := min{k | log (k)(N) <= 1} Лас-Вегас алгоритмом побудованим Кларксоном [9] та теж подалі спрощений Сейделем [10]. Так як log* N є майже сталим значенням, це наштовхнуло на запитання, чи може полігональна триангуляція бути виконана за лінійний час - тривіальна нижня межа вхідних даних. Відповідь на неї знайшов Чазеле [1], що відкрив детерміноване лінійне рішення цієї задачі. Як виявилось, програмна реалізація та концептуальне розуміння є непростим, тому з’явилась потреба у спрощенні алгоритму. На це була запропонована рандомізована версія методу [10], що спростила реалізацію. Але задача простого детермінованого лінійного алгоритму залишається відкритою по сьогоднішній день. 
Так, ця робота робить наступний крок у знаходженні покращенного детермінованого лінійного алгоритму, а саме теоретичну та практичну побудову r log r + O(N) алгоритму триангуляції, концептуальні ідеї якого можуть бути використані в спрощенні алгоритму. Алгоритм є в 10 разів швидше алгоритму Гарея [3] та в 3 рази швидшим за алгоритм Гертеля [6]. Варто зауважити, що алгоритм є значно простіше концептуально та практично.
Новизна та ідея. Запропонований новий швидкий алгоритм складністю r log r + O(N), що має наштовхнути на спрощення та пришвидшення алгоритму полігональної лінійної триангуляції. 
Мета статті. Зробити детальний розгляд методів триангуляцій та запропонувати новий метод, що виконуєтся за r log r + O(N). 
2 Основна частина. 
Сформулюємо геометричну постановку задачі полігональної триангуляції. 
Постановка задачі триангуляції простого полігону. Нехай заданий замкнений простий полігон, тобто послідовність ребер P={(v1, v2), (v2, v3) …, (vn-1, vn), (vn, v1)} - така, що vi != vj, та ребра не перетинаються (окрім звичайно їх спільної вершини, якщо вони послідовні). Тоді задача триангуляції простого полігону полягає у знаходженні такої множини непертинаючих трикутників на площині, де кожна вершина трикутника є однією із вершин ребра полігона P, сумарне об’єднання яких дає в сумі площу, обмежену кривою P. 
2.1 Детальний аналіз існуючих алгоритмів 
В даному розділі наведемо загальні риси кожного із найкращих із теоретичної та практичної зору алгоритмів, їх обгрунтування та основні деталі. 
2.1.1 Алгоритм “Ear-clipping” 
“Ear-clipping” [2] є безумовно найпростішим алгоритмом полігональної триангуляції, але наведемо спочатку важливе означення. 
Означення. Діагоналлю полігона P називається відрізок, що з’єднує дві його вершини та лежить повністю всередині P. 
Тоді алгоритм зводиться до пошуку діагоналі за час O(N), та рекурсивниого виклику триангуляції для обох частин. Точніше, беруться 3 послідовні вершини v1, v2, v3 полігона, що мають внутрішній кут < 180 градусів (це час O(N)), йде перевірка чи належить ця діагональ полігону за час O(N), якщо так - відрізаємо та продовжуємо рекурсивно, якщо ні - знаходимо вершину, найдальшу від (v1, v3) всередині трикутника v1v2v3 за час O(N) та проводим діагональ між v1 та цією вершиною. Нескладно довести що ця діагональ дійсно буде лежати повністю всередині полігона. Отже маємо: 
T(N) <= T(N-1) + O(N), 
що має очевидний розв’язок T(N)=O(N²). 
2.1.2 Алгоритм Гарей 
Першим алгоритмом, який подолав складність O(N²) до O(N log N) був алгоритм Гарея [3], загальна ідея якого полягає у: 
1) Регуляризації полігона по осі y. (див. Рис.1.a) 
2) Прибиранні утворених відрізків, що не лежать в P, тобто не є діагоналлями. (див. Рис.1.b) 3) Утворені діагоналі розбивають P на y-монотонні полігони, які сумарно триангулюються за лінійний час. (див. Рис.1.c)
  

Рис.1. (a) - регуляризація, (b) - прибрання зовнішніх відрізків, (с) - триангуляція [3]. Розглянемо детальніше основні компоненти алгоритму. 
2.1.2.1 Регуляризація 
Означення. Вершина полігона P є регулярною, якщо одне її ребро вище її, а інше - нижче. Інакше, вершина називається нерегулярною. 
Тоді, в результаті регуляризації полігону, для кожної нерегулярної вершини в якій нема ребра над чи під цією точкою додається ребро, щоб воно було. В [11-12], алгоритм розбитий на наступні кроки: 1) Сортуємо вершини полігону по y координаті. 
2) Ініціалізуємо дерево трьома інтервалами з найвищої точки - зліва від точки, який вона утворює, та спава. 
3) Проходимо горизонтальною “sweep-line” лінією зверху вниз, на кожному кроці зберігаючи в дереві всі інтервали, які пересікає ці лінія. Так, коли ми проходимо кожну вершину, для кожного ребра яке знаходиться зверху від точки вилучаються всі інтервали, між якими розташовані ці ребра. Аналогічно для кожного ребра знизу, додаються інтервали, між якими знаходяться ці ребра. Коли додаємо інтервал, також додаємо посилання на вершину, яка додала цей інтервал - назвемо її генератором. Тоді, коли видаляємо інтервал, проводимо діагональ між поточною вершиною та генератором цього інтервалу. 
Наприклад в 3), якщо вершина має два ребра зверху, 3 інтервали між якими вони стоять будуть прибрані і додсться один суцільний інтервал. Кожна вставка та вилучення займає O(log N) часу, а кожна вершина має тільки два суміжних ребра, отже сумарна вартість не буде перевищувати 4 N log N = O(N log N). Тоді сумарна вартість, включаючи початкове сортування обмежена зверху 5 N log N = O(N log N). 
Також, проведена діагональ в 3) дійсно буде лежати в полігоні, бо завжди зберігається інваріант, що будь який відрізок між генератором та точкою цього на інтервалу буде повністю лежати в полігоні. Отже, наведений алгоритм регуляризації коректно будує діагоналі та регуляризує вершини за час O(N log N). 
2.1.2.2 Триангуляція монотонних полігонів 
Означення. Полігон P називається y-монотонним, якщо будь яка горизонтальна лінія перетинає ребра цього полігон не більше ніж два рази. 
Так, триангуляція монотонних полігонів [3-4] може бути виконана за час O(N) починаючи з найверхньої точки наприклад, зберігаючи на кожному кроці нижчу точку лівого ребра цієї точки та стек із вершин справа, які ще не до кінця протриангульовані. Тобто, стек ініціалізається порожнім, та кожен крок, для поточної найверхньої вершини vi, розглядається її ліве ребро (vi-1, vi) та до стеку додаються вершини ребер справа, доки їх y-координата не буде нижча y-координати vi. Кожен раз, додаючи вершину справа до стеку, перевіряється чи три останні вершини зі стеку утворюють внутрішній кут < 180 - якщо так, додаємо діагональ між останньою точкою та кожною точкою зі стеку, послідовно
вилучаючи їх, інакше йдемо далі. Тоді, кожен раз додаючи нову точку справа та триангулюючи за потреби утворюється інваріант - одне ребро зліва та всі ребра справа утворюють між собою внутрішній кут >=180 - так звана “воронка”. Дійшовши до ребра справа, нижня точка якого нижче y-координати нижньої точки vi-1 ребра зліва, враховуючи структуру воронки, можемо проводити діагоналі із точки vi-1 до всіх інших точок із стеку, вилучивши їх всі. Таким чином, vi-1 стає найверхньою точкою нетруангульованої частини полігона, яку можна триангулювати рекурсивно, за такою самою процедурою. 
Враховуючи, що кожна вершина оброблена не більше ніж 2 рази, час виконання триангуляції монотонного простого полігона - 2 N = O(N). 
2.1.3 Метод монотонних полігонів 
Наступний розглянутий метод [4] відрізняється від методу Гарея етапом регуляризації, а саме, кожна точка класифікується на: 
1) start - обидва суміжних ребра знаходяться нижче від точки, та внутрішній кут < 180 градусів. 2) end - обидва суміжних ребра знаходяться вище від точки, та внутрішній кут < 180 градусів. 3) split - обидва суміжних ребра знаходяться нижче від точки, та внутрішній кут >= 180 градусів. 4) merge - обидва суміжних ребра знаходяться вище від точки, та внутрішній кут >= 180 градусів. 5) regular - віс інші, тобто які мають одне ребро - вище, а інше - нижче за точку. 
Тобто, точки start - верхні локальні екстремуми, end - відповідно нижні, split - в процесі алгоритму з них будуються діагоналі вверх для “розділення” полігону, merge - точки в які проводяться діагоналі знизу, та “зливають” новий полігон. Отже, замість регуляризації, проводяться діагоналі до кожної split та merge точки, бо саме вони порушують y-монотонність полігона P. Формально: 
Теорема. Якщо простий полігон не містить точки виду split та merge, він є y-монотонним. 
Доведення. Від супритовного, якщо існують, не складно провести горизонтальну лінію, що перетинає ребра полігона >= 4 рази. 
Так, провівши такі діагоналі, кожен з отриманих полігонів можна триангулювати методом, описаним в розділі 2.1.2.2. 
Для проведення діагоналей відбувається обхід всіх вершин зверху вниз горизонтальною “sweep-line” лінією, зберігаючи в дереві T всі ребра полігона, що перетинаються цією лінією та мають інтер’єр полігону справа. Кожне таке ребро (vi, vi+1) має посилання на її “helper”, що є найвищою необроблена вершиною полігона, справа від цього ребра, та для якої це ребро є найближчим зліва. Відповідно, коли додається ребро, її “helper” ініціалізується верхньою вершиною цього ребра. Тоді, проходячи всі вершини зверху вниз, згідно поточної точки, відбуваються наступні дії: 
1) start - в T додається її ребро зліва. 
2) end - знаходиться ребро в T, зліва від цієї вершини, та проводиться діагональ між цією вершиною та “helper” цього ребра якщо він виду merge. Також, це ребро прибирається з T, бо “sweep-line” спускається вниз. 
3) split - також, знаходимо ліве ребро в T, проводиться діагональ якщо “helper” - виду merge. Відповідно, “helper” цього ребра оновлюється на поточну точку. При цьому, додаємо ребро знизу від поточної точки, також через “sweep-line”. 
4) merge - шукаємо ліве ребро в T, додаємо діагоналі до її “helper”, якщо він є merge, оновлюючи його в будя якому випадку. Також знаходим “helper” правого ребра цієї вершини в T, якщо merge, проводимо діагональ. Знову ж таки, через “sweep-line”, видаляємо це праве ребро. 5) regular - два випадки: 
a) Якщо вершина - зліва від інтер’єру полігона, проводимо діагональ між нею, та “helper” ребра справа від поточної (якщо він виду merge звичайно).
b) Інакше, знаходимо в T ліве ребро від цієї вершини, проводимо діагональ якщо - виду merge. 
В будь-якому випадку, видаляємо ребро зверху та додаємо ребро знизу від поточної вершини в T. 
Підсумовуючи, алгоритм проходить горизонтальною лінією зверху вниз, зберігаючи дерево ребер, що перерізає ця лінія, та їх “helper”, що зберігає інформацію про останній необроблену вершину merge, що дозволяє проводити діагоналі до них з вершин end, split, merge, regular в подальшій обробці. Очевидно, на кожному кроці проходить не більше 2 перевірок з дерева T - час 2 log N. Так, побудувавши діагоналі, отримуєм розбиття полігону на у-монотоні підполігони, що триангулюються за час O(N), отже враховуючи сортування, сумарний час складає 3 N log N + O(N) = O(N log N). 
2.1.4 Метод розділяй та володарюй 
Наступним важливим методом триангуляції є метод розділяй та володарюй Чазеле та Інсерпі [5], що працює за часO(N log N), або точніше, O(N log S), де S - кількість “спіралей” в полігоні. Спочатку введемо деякі означення. 
Означення. L - ланцюг, якщо є не обов’язково замкненою підмножиною послідовних ребер з P. 
Означення. Нехай ребра простого полігона P орієнтовані за часовою стрілкою. Тоді, L-подовженням (вертикальна хорда) у вершині vi ланцюга L1 називається об’єднання двух лучей з vi - один направлений вверх, та зупиняється, коли перший раз дотикається правої частини орієнованого ребра P, а другий - вверх, аналогічно (див. Рис. 2). 
Означення. Вертикальною декомпозицією VD(L1) ланцюга L1 називається об’єднання L-подовжень всіх її вершин. (див. Рис. 3) 
Означення. Точки підтримки вершини простого полігона vi називаються точки перетину L-подовження vi з ребрами P. 
Означення. Кожен сегмент розбиття ланцюга L1 точками підтримки з VD(L1) та вершинами L1 називається VD-ребром. 
Означення. Трепецією з вершин vi, vj з підмножини послідовних ребер L1 називається регіон, обмежений L-подовженнями vi та vj. Коректно визначена трапеція не має на своїх сторонах інших вершин P крім vi та vj. 
  

Рис.2. L-подовження вершин P [5].
  

Рис.3. Вертикальна декомпозиція P [5]. 
Основна задумка алгоритму є побудова вертикальної декомпозиції полігону за час O(N log S), та подальша триангуляція за O(N). Розберемо кожен з етапів детальніше. 
2.1.4.1 Побудова вертикальної декомпозиції 
Для отримання вертикальної декомпозиції використовується метод “розділяй та володарюй”. Для цього, послідовність ребер полігону L розділяється на два ланцюги L1={(v1, v2), … (vn/2-1, vn/2)}, та L2={(vn/2, vn/2+1), … (vn-1, vn)}, будуються вертикальні декомпозиції VD(L1) та VD(L2), які послідовно зливаються в VD(L). Нехай {(w1, w2), …, (wn/2-1, wn/2)} та {(wn/2, wn/2+1), …, (wn-1, wn)} - відповідні множини VD-ребер для L1 та L2. Тоді, пересуваючи один з вказівників на VD-ребро p1:= (wn/2-1, wn/2) - на один ближче до (w1, w2), або p2:= (wn/2, wn/2+1) - на один ближче до (wn-1, wn), перевіряючи всі 6 можливих частинних випадків (Рис. 4), зливаємо поточні VD-ребра, отримуючи інваріант: 
Інваріант. На кожному кроці злиття, маємо побудовану вертикальну декомпозицію VD-ребер між ребрами p1 та p2. 
Тоді коли точки досягають країв, отримуємо шукану декомпозицію VD(P). Відповідно, враховуючи щонайменш перевірку 6 частинних випадків та зсув вказівника на кожному кроці, для часу маємо: 
T(N) <= 2T(N/2) + 7 N, 
що має класичний розв’язок 7 N log N = O(N log N). Надалі зрозуміємо краще, як саме досягається O(N log S).
  

Рис. 4. Всі частинні випадки [5]. 
Для цього, трохи деталізуємо крок побудови вертикальної декомпозиції між p1 та p2. На початку, ребро p2 просто пересувається на одне ребро поки воно не перетинатиметься з p1 вертикальною осею (див. Рис. 4), залишаючи всі трапеції цього ланцюга якими є. Зауважимо, що частина ланцюга, що потрапила в регіон трапецій від p1 до p2 буде оброблена пізніше, за допомогою прибрання “побочних ефектів” (див. Рис.5) - головне, що зберігається інваріант. Далі, відповідно до кожного з 6 випадків, додається нова трапеція, та p1 або p2 пересуваються на одне ребро. Не втрачаючи загальності, нехай лівий край p1 - лівіше за p2 (інакше, випадки симетричні). Тоді, на рис. 4, трапеції F - позначають нову розлядаючу трапецію та C - не до кінця оброблена трапеція, частина якої вже була покрита трапецією, а N - трапеція, яка стане F після цього кроку. Вважаємо малюнки самоочевидними, але важливо, що якраз випадок (e) дозволяє перестрибнути вказівнику p1 всі ребра зліва, що утворюють “спіраль”, звідки має інтуїтивно випливати log S замість log N. 
Варто зазначити, що коли ребро p1 чи p2 заходить в область, вже оброблену та покриту трапеціями, відбувається виклик прибрання “побочних ефектів”, що видаляє та додає відповідні трапеції згідно із випадком (a) чи (b) на рис. 5. 
  

Рис.5. Прибрання “побочних ефектів” [5]. 
2.1.4.2 Триангуляція вертикальної декомпозиції
Отримамана вертикальна декомопозиція полігона P використовується для побудови діагоналей, що розіб’ють полігон P на монотонні полігони, що триангулуються методом, описаним в 2.1.2.2. Конкретніше, для кожної отриманої трапеції t, перевіряється чи одна з її вертикальних сторін породжена точкою v має дві точки підтримки - зверху та знизу, тобто v - точка рефлексії. Якщо так, будується діагональ з v до w - вершина, що породжує іншу сторону трапеції (див. Рис. 6). Аналогічно з теоремою в розділі 2.1.3, не складно довести, що побудовані діагоналі дійсно розбивають полігон на монотонні підполігони. 
  

Рис. 6. Діаноналі вертикальної декомпозиції [5]. 
Отже, так як побудова вертикальної декомпозиції займає час N log S, а її триангуляція - 4 N = O(N), сумарний час роботи алгоритму - O(N log S). 
2.1.5 Метод Кірпатік 
Першим методом, що поборов межу O(N log N) у загальному випадку був O(N log log N) алгоритм Таржанa [7], але в даному розділі розглянемо її спрощенний Кірпатіком [8] варіант, який також досягає межі O(N log log N). Метод є важливим більше концептуально ніж практично, та об’єднує важливі ідеї, які використовуються в найкращому лінійному алгоритмі Чазеле [1], та можуть бути використані в майбутньому, для покращення алгоритмів триангуляції. 
Отже, загалом, алгоритм також працює за принципом “розділяй та володарюй” для побудови горизонтальної декомпозиції полігона, що триангулюється методом, аналогічним з 2.1.4.2. Для початку, адаптуємо та введемо базові означення: 
Означення. Горизонтальна декомпозиція - визначається аналогічно вертикальній, означеній в розділі 2.1.4, тільки для горизонтальних лучів. Для вершини vi, точка підтримки h(vi) (в оригіналі статі - сусід точки) також визначається аналогічно. 
Означення. k-рівномірне розбиття називається розподілом простого полігона довжини N на ланцюги (в оригіналі статі - сегменти), кожен розміру від k/2 до k, кожен з яких має побудовану окремо горизонтальну декомпозицію. Таке розбиття простого полігону породжує розбиття полігона на шматки (див. Рис. 7).
  

Рис.7. Розбиття полігону на шматки [7]. 
Тоді, в основі, алгоритм поділяється на наступні кроки: 
1) Початковий полігон довільно розбивається на ланцюги розміру від ½N^⅔ до N^⅔ . 2) Для кожного ланцюга рекурсивно окремо рахуємо їх горизонтальні розбиття - отримуємо k-рівномірне розбиття, де k = N^⅔. 
3) Використовуючи ці розбиття, знаходимо особливу вершину для кожного ланцюга (див. нижче) - за лемою 1, за час O(N). 
4) Для кожної особливої вершини знаходиться її горизонтальний сусід (за лемою 2 - час O(N)) , використовуючи це розбиття - отримуємо кінцеву декомпозицію для сталої частини всіх вершин (за лемою 3 - така стала c < 1 існує) - це “хороші” шматки (див. нижче). 
5) Використвуючи k-рівномірне розбиття полігона P, будуємо k-рівномірне розбиття для кожного з “поганих” шматків , що є полігонами, для яких декомпозиція не є кінцевою - за лемою 4, за час O(N). 
6) Рекурсивно, для кожного з “поганих” шматків, маючи доступ до їх k-рівномірних розбиттів, використовуємо цю процедуру рекурсивно, для кожного із шматків. 
Тоді маємо наступні співвідношення: 
T(N) = sum T(ni) + sumT(bi) + O(N) <= n^⅓ T(n^⅔) + T(c * N) + O(N), де sum(ni) = N, sum(bi) = c * N, ni <= n^⅔, c < 1, з чого випливає, що час алгоритму становить T(N) <= O(N log log N). 
Введемо відсутні означення: 
Означення. Особливою вершиною vi в одному з ланцюгів L k-рівномірного розбиття називається вершина полігона P, для якої виконується: 
1. Частина ланцюга полігона між vi та h(vi) та інша частина мають не менше k/36 вершин. 2. Вершина vi розділяє L на дві частини, кожна з яких має не менше k/36 вершин. 
Означення. Шматок розбиття полігона горизонтальними хордами є “хорошим”, якщо має 2 або менше горизонтальних хорд на своїй границі, відповідно “поганим” інакше. 
Наведемо також всі допоміжні леми без доведень:
Лема 1. Кожен з підланцюгів k-рівномірного розбиття містить особливу вершину, яку можна знайти за час O(k). 
Лема 2. Якщо vi - вершина підланцюга L k-рівномірного розбиття, то за час O(k) можна знайти h(vi). Лема 3. Існує стала с < 1 така, що “поганих” шматків не більше c * N. 
Лема 4. k-рівномірне розбиття всіх шматків можна побудувати за час O(N). 
Отже, суть алгориту полягає в розбитті полігона на ланцюги порядку N^⅔, рекурсивній побудові горизонтальних декомпозицій для кожної частини, знаходженя особливих точок, що визначають більшу частину простих кінцевих горизонтальних декомпозицій, та нарешті добудова хорд до залишившихся шматків, отримуючи час O(N log log N). Так, аналогічно методу 2.1.4, нескладно триангулювати отриману декомпозицію за час O(N), отримавши кінцеву складність O(N log log N) + O(N) = O(N log log N). 
2.1.6 Рандомізований алгоритм Сейделя 
Найбільш практичним та швидким на поточний момент є рандомізований алгоритм Сейделя [10], який в середньому виконується за час O(N log* N), що є близьким до лінійного. Подібно до двох попередніх методів, даний алгоритм на першому етапі будує розбиття полігону на y-монотонні полігони, та на другому етапі, триангулює кожну з частин за лінійний час у сумі. Основною різницею є використання на першому етапі динамічних структур даних, та послідовна вставка в них у випадковому порядку всіх ребер полігона P. Отримана структура даних далі може бути використана для проведення діагоналей та подальшої триангуляції. 
Конкретніше, для представлення поточної підмножини ребер S простого полігона P, введемо спочатку два означення: 
Означення. Для підмножини S ребер P, горизонтальним подовженням з вершини vi точки ребра S є об’єднання двух лучей, що направлені направо і наліво відповідно, та закінчуються при першому ж перетині з S (див. Рис.8). 
Означення. Планарний граф, утворений горизонтальними продовженнями зі всіх вершин S називається трапезоїдацією, та позначається T(S). 
  

Рис.8. Горизонтальні продовження з кожної точки підмножини ребер S [10].
Тоді можна використати T(S) для представлення поточних ребер. Але цього недостатньо, бо невідомо як саме, за час O(logN) вставляти нові ребра в T(S). Для цього вводиться додаткова структура Q(S) для пошуку точок в трапеціях, породжених T(S), яка представляється у вигляді ациклічного графа, де кожен листок це трапеція, а проміжний вузол може бути Y-вузлом, якщо містить вершину відрізка або X-вузлом, що буде містити ребро (див. Рис.9). Тоді, для локалізації трапеції, в якій знаходиться точка q, потрібно пройти від вершини дерева до листка, що відповідає шуканій трапеції, на кожному кроці перевіряючи для Y-вузла чи знаходиться точка вище чи нижче, або для X-вузла, справа чи зліва від відповідного ребра. 
  

Рис.9. Трапезоїдація T(S) та відповідний їй граф Q(S) для пошуку [10]. 
Маючи T(S) та Q(S), для додавання нового ребра (vi, vi+1) з P в T(S) достатньо знайти вершини vi та vi+1 в Q(S), додати до T(S),та для нових вершин розбити трапеції в які вони потрапляють на частини, змінивши поточну трапецію в Q(S) на Y-вузол, та утворені трапеції як листки. Також, сегменти ребра (vi, vi+1) можуть розділяти деякі трапеції, тому оновлюємо T(S) розбиваючи трапеції, які перетинає (vi, vi+1) навпіл, та роблячи відповідні трапеції в Q(S) X-вузлами, з новими трапеціями як листками. 
Перед розглядом алгоритмів та аналізом середнього часу, наведемо як саме можна використати T(P) для побудови діагоналей та подальшої триангуляції. Це робиться, провівши діагоналі в трапеціях інтер’єру P, в яких права та ліва грань мають вершини P (див. Рис.10). Далі, утворені полігони можуть триангулюватись алгоритмом в розділі 2.1.2.2 за час O(N). 
Тепер розглянемо дві варіації алгоритму побудови T(S) та Q(S), перша з яких є більш спрощенною, але працює за час O(N log N) в середньому, а друга відповідно O(N log* N). В першій варіації, Q(S) та T(S) ініціалізуються порожніми, та до них додаються нові випадкові ребра з P, оновлюючи структури даних. Наведемо дві теореми, що свідчать про саме час O(N log N) побудови T(P):
  

Рис.10. (a) - розбиття на трапеції T(S) в інтер’єрі P, (b) - проведення діагоналей, (c) - утворене розбиття P [10]. 
Теорема. При заданій T(S) з K кількістю випадкових ребер з P, середня кількість горизонтальних подовжень T(S), які перетинатимуть нове ребро (vi, vi+1) буде не перевищувати 4. 
Теорема. При заданій T(S) з K кількістю випадкових ребер з P, середня кількість запитів для знаходження довільної точки q в Q(S) становить 5 log K = O(log K). 
Так, очевидно що просто додавши всі ребра, сумарно отримуємо середній час O(N log N). Модифікований алгоритм, що працює за час O(N log*N) полягає у пришвидшенні пошуку недоданих ще вершин із P, періодично проводячи їх пошук в поточній недобудованій Q(S). Ця інформація може бути використана при доданні ребра з цими вершинами в наступних кроках, для ініціалізації пошуку. 
Теорема. При заданій випадковій множині ребер R та її надмножиною S, кількість перетинів S\R з T(R) не буде перевищувати 4(|S|-|R|). 
Теорема. При заданій випадковій множині ребер R та її надмножиною S, знаючи положення точки q в T(R), за час 5log(|S|/|R|) можна знайти її в T(S). 
Також, для визначення періоду, як побачимо, природнім є вибір точок в яких відбувається оновлення кожні N(k) = [N/log(k) N] ітерацій. 
Тепер наведемо сам алгоритм: 
1) Перемішуємо порядок ребер, ініціалізуємо першим ребром S_0={(vi, vi+1)} структури даних T(S_0) та Q(S_0). 
2) Для всіх 1 <= k < log* N: 
a) Для всіх N(k-1) < i <= N(k): 
i) Додаємо випадкове нове ребро з P до S_i, оновлюємо T(S_i) та Q(S_i)
b) Оновлення початкових положень точок P використовуючи S_N(k). 
3) Для всіх N(log*N) < i <= N: 
a) Додаємо випадкове нове ребро з P до S_i, оновлюємо T(S_i) та Q(S_i) 
Отже, за двома теоремами вище, час i) становить O(log(N(k)/N(k-1))) = O(log(N/N(k-1)))=O(log(k)N), log*N ітерацій, отже отримуємо час O((log* N)^2). Для b), час виконання - O(N(k) - N(k-1)) = O(N), отже теж сумарний час O(N log*N). І нарешті 3), кожен крок використовує ініціалізації T(S_N(log*N)) та Q(S_N(log*N)), отже сумарний час - O(N log (N/N(log*N)))=O(N log*N). Тоді, всі кроки в сумі дають O(N log* N). 
Підсумовуючи, алгоритм Сейделя викристовує випадкову перестановку ребер полігона P та їх послідовну вставку в динамічні структури даних з періодичним оновленням розташувань необроблених вершин. Це дає змогу побудувати розбиття полігону на трапеції за час O(N log*N), що надалі дає змогу трангулювати отриману структуру за лінійний час. 
2.1.7 Лінійний алгоритм Чазеле 
І нарешті, розлянемо дуже детально лінійний детермінований алгоритм триангуляції Чазеле [1], який хоча й найшвидший з відомих, вважається складним теоретично та практично. Для цього, надамо простіші пояснення, алгоритмічні деталі, та доведення теорем, без втрати основної структури та глибинних ідей. В кінці розділу також наведемо ідеї для покращення та спрощення алгоритму, визначивши напрями подальшого розвитку. 
Отже, загалом, алгоритм, як і попередні, заснований на побудові горизонтальної декомпозиції та подальше триангулювання, причому кожен з етапів є лінійним за часом. Лінійність першого етапу досягається двома основними кроками (див. Рис.11): 
1) Фаза вверх - початковий простий незамкнений полігон розбивається на ланцюги, будується горизонтальна декомпозиція для кожного, та відбувається злиття в довші ланцюги. В процесі, для кожного ланцюга будується структура даних “ray-shooting oracle”, яка використовується для сублінійного пошуку горизонтальних сусідів точок при подальшому злитті. 
2) Фаза вниз - Поступово додає до часткової горизонтальної декомпозиції хорди в тому ж дусі, отримаючи в кінці повну декомпозицію. 
  

Рис.11. Дві фази алгоритму Чазеле [1].
Важливо, що на кожному підкроці 1) деякі хорди прибираються та додаються для підтримання так званої ɣ-гранулярності та конформальності розбиття - саме ці компоненти стоять в корні лінійності алгоритму. Інтуїтивно, ɣ-гранулярность означає, що кожен з шматків часткової горизонтальної декомпозиції має розмір не більше O(ɣ), що дозволяє балансувати процедуру. Конформальність з іншого боку означає, що при частковій горизонтальній декомпозиції, ніякий шматок горизонтально розбиття не має більше ніж 4 інших сусдніх шматка. Зауважимо, що кінцева повна горизонтальна декомпозиція завжди є конформальною. 
Почнемо розбирати компоненти алгоритму більш детально. Для цього введемо означення: 
Означення. Частковою горизонтальною декомпозицією ланцюга L незамкненого простого полігона P називається пона горизонтальна декомпозиція L, з вилученням якоїсь кількості хорд. 
Означення. Аркою шматка часткової горизонтальної декомпоозиції називається послідовність ребер з L на грані цього шматка, яка сполучає дві вершини горизондальної хорди цього шматка. 
Означення. Вага шматка горизонтального розбиття називається максимальна довжина його арки. 
Означення. Деревом горизонтальної декомпозиції називається дуальний граф, що асоціюється з відповідною частковою горизонтальною декомпозицією (див. Рис.12). Відповідно, кожун вузол має свою вагу. 
Означення. Часткова горизонтальна декомпозиція є ɣ-гранулярною, якщо виконується: 1) Кожен вузол дерева цієї декомпозиції має вагу не більше ɣ. 
2) Суміжні вузли дерева не можна злити, отримавши відповідний шматок, вага якого буде не більше ɣ - властивість мінімальності. 
Очевидно, що ɣ-гранулярні декомпозиції не будуть мати занадто великі шматки, а саме, їх розмір не буде перевищувати O(ɣ) та кількість - O(N/ɣ). 
Означення. Часткова горизонтальна декомпозиція є конформальною, якщо кожна її вершина має не більше 4 ребер. 
  

Рис.12. Дерево часткової горизонтальної декомпозиції [1].
Означення. Ланцюгом λ-рівня називається послідовність ребер {(vi, vi+1), …, vj-1, vj)}, де j - i = 2^λ 
2.1.7.1 Фаза Верх 
У фазі вверх, отримуючи на вхід незамкнений простий полігон розмірності 2^p+1, він розбивається на на ланцюги λ-рівня 0,1,..., p, кожен з яких має 2^[λ/5]-гранулярну та конформальну часткову горизонтальну декомпозицію. Ці ланцюги рекурсивно зливаютсья парами, проводяться до правильної форми, будуються “ray-shooting oracle” для наступного рівня, та в кінці отримується часткова, 2^[p/5]-гранулярна декомпозиція. Розпишемо кожен з етапів детальніше, наводячи теореми. 
2.1.7.1.1 Злиття 
Не заглиблюючись сильно в деталі, фаза злиття проходить по кожному з двох ланцюгів, та проводить лучі направо та наліво в кожній вершині, доки не торкнеться себе ж або іншого луча. В цьому процесі використовується структура даних “ray-shooting oracle”, побудована на попередньому рівні для кожного з ланцюгів. Таким чином, маємо наступну теорему: 
Теорема. Злиття двох ɣ-гранулярних декомпозицій ланцюгів L1 та L2 розмірності N1 та N2 відповідно, можна побудувати за час O((N1/ɣ + N2/ɣ + 1)(f(ɣ) + log(N1 + N2))), де f(ɣ) - час на виконання пошуку горизонтального сусіда в L1 та L2. Доведено, що f(x)=x^0.7. 
2.1.7.1.2 Відновлення конформальності 
Отрамане злиття може порушувати конформальність, тому для її відновлення треба додати хорди, що будуть перекривати інші, для зменшення кількості сумідних шматків. 
Формально, маємо: 
Теорема. Відновлення конформальності часткової горизонтальної декомпозиції може бути виконанена за часґ O(f(ɣ)g(ɣ)(h(ɣ) + log ɣ)), де g(ɣ) - час на розбиття дерева декомпозиції, та h(x)=x^0.2. Також доведено, що g(x)=O(log x). 
2.1.7.1.3 Відновлення ɣ-гранулярності 
Після додавання ребер та відновлення конформальності, гранулярність не збільшилась, але властивсть 2) може порушуватись, отже для її відновлення треба злити в одне шматки, поки це можливо і ми дійсно не отримаємо ɣ-гранулярну декомозицію. Формалізуємо: 
Теорема. Нехай задані ɣ-гранулярні конформальні ланцюги L1 та L2 розміру N1 та N2 вілповідно, в якиз порушується умова 2). Тоді, її можна відновити за час O((N1/ɣ + N2/ɣ)f(ɣ)g(ɣ)(h(ɣ) + log (N1 + N2))). 
2.1.7.1.4 Побудова “ray-shooting oracle” 
В кінці фази, будується “ray-shooting oracle”, який буде використовуватсь в подальшому злитті на наступному рівні. Це також можна формалізувати теоремою: 
Теорема. Нехай заданий ɣ-гранулярний конформальний ланцюг L розміру. Тоді, “ray-shooting oracle” можна побудувати за час O(N log N / ɣ), час виконання пошуку для якого буде становити O(ɣ (N/ɣ)^(2/3)). 
2.1.7.2 Фаза Вниз 
Ця фаза використовує “ray-shooting oracle”, побудовані на останньому кроці для покрокового злиття методом, описаним в 2.1.7.1.1. Маємо теорему: 
Теорема. Фаза вниз може бути виконана за час O(N).
Отже, алгоритм Чазеле [1] побудови горизонтальної декомозиції розбитий на два етапи, кожен з яких виконується за лінійний час, тому сумарний час - O(N). 
2.2 Запропонований алгоритм 
Ідея алгоритму полягає у знаходженні горизонтальних хорд в точках рефлексій (див. нижче), що можна зробити за час r log r + O(N), і подальше визначення діагоналей та триангуляція за час O(N). Для знаходження горизонтальних хорд, відбувається сортування точок рефлексій за y-координатою та лінійний прохід знизу вверх, проводячи горизонтальні хорди та зменшуючи полігон доки всі точки рефлексій не будуть оброблені. 
Означення. Горизонтальною хордою із вершини полігону P називається пряма, утворена двома лучами, що йдуть направо і наліво від точки доки не перетнуть ребро P. 
Означення. Вершина полігону називається точкою рефлексії, якщо її внутрішній кут більше 180 градусів та обидва суміжних ребра вище за точку або обидва - нижче. 
Множина всіх горизонтальних хорд із точок рефлексій представляється графом R, де кожен вузол - точка рефлексії, а вузли з’єднані, якщо регіон між цими горизонтальними хордами в цих точках не містить інших хорд (див. Рис. 13). Також, кожен вузол зберігає посилання на праве і ліве ребро, які обмежують горизонтальну хорду із відповідної точки рефлексії. Наведемо важливу властивість цього представлення: 
  

Рис.13. Граф R, представлений вершинами та заштрихованими ребрами. 
Теорема. Для кожного вузла r графу R, в якого два суміжні ребра нижче (вище) від точки виконується: 1) Вузол r не може мати більше одного ребра R, що лежить вище (нижче) за r. 
2) Вузол r не може мати більше двух ребер R, що лежать нижче (вище) за r. 
Ця теорема дає змогу, використовуючи граф R, легко розбити полігон P на y-монотонні за лінійний час. А саме, для кожної точки рефлексії r графа R, якщо в неї два суміжні ребра нижче (вище), проводиться діагональ з неї до найнижчої (найвищої) вершини з трьох (див. Рис. 14): 1) Верхня (нижня) вершина правого опорного ребра горизонтальної хорди точки r.
2) Верхня (нижня) вершина лівого опорного ребра горизонтальної хорди точки r. 3) Рефлексна вершина r’ в R, яка має спільне ребро зверху (знизу) від точки r. 
Тоді, проведені таким чином діагоналі розіб’ють полігон на y-монотонні частини, бо більше рефлексних вершин в них не буде. Далі, не складно триангулювати отримане розбиття за лінійний час методом, описаним в розділі 2.1.2.2. Отже, якщо заданий граф R, полігон P можна триангулювати за час O(N). 
  

Рис.14. Побудова діагоналей, використовуючи граф R. 
Тепер, розглянемо детальніше етап побудови графу R за час r log r + O(N), вважатимемо, що ребра полігона P орієнтовані за годинниковою стрілкою. На початку, за один прохід по границі полігона P, будується циклічний двозв’язаний список рефлексних вершин та правих vi-1 і лівих vi+1 вершин від точок нижніх екстремумів vi. При додаванні до цього списку рефлексної вершини, ця вершина також додається до окремого масиву рефлексних вершин. Отже, після проходу маємо двозв’язаний список рефлексних вершин, що чередується із правими і лівими від нижніх екстремумів вершинами (Рис. 15) та окремий масив рефлексних вершин, який можна відсортувати по y-координаті за час r log r. Тепер, алгоритм буде проходитись від нижньої до верхньої рефлексної вершини, проводячи горизонтальні хорди, відсікаючи від полігона оброблені частини та розділяючи його на незалежні частини, додаючи до R нову вершину та проводячі нові ребра на кожному кроці. Зауважимо, що завжди буде зберігатись інваріант, що цей двозв’язаний список буде складатись із послідовності рефлексних вершин, далі чергування рефлексних з двома точками між цими рефлексними вершинами - частина між цими двома точками буде завжди обробленою та не буде мати інших точок рефлексій, і в кінці цього списку - знову послідовність рефлексивних вершин. Також, кожен елемент двозв’язаного списку має також вказівник на відповідну вершину в полігоні P, та додатковий вказівник на рефлексну вершину R, що використовується для побудови графа R. Цей вказівник ініціалізується нульовим, і детальніше розлянемо його використання надалі. Також, варто зауважити, що в процесі роботи алгоритму, коли полігон ділиться на частини, цей список може розділятись на частини, тому кожна рефлексійна вершина у відсортованому списку має також вказівник на елемент двозв’язаного списку якому вона належить.
  

Рис.15.Рефлексійний двозв’язний список полігона P. 
Отже, ініціалізувавши двозв’язаний список, починаючи з нижньої рефлексної вершини r, для списку якому вона належить, може бути два випадки: 
1) Якщо r має два суміжні ребра нижче, тоді не складно довести що для неї буде по дві нерефлексних вершини в списку справа vi, vk і зліва vm, vj, отже пересувачи найлівішу vi та найправішу vj з них по границі подалі від r, доки (vi-1, vi) не буде лівим опорним ребро горизонтальної хорди з r та (vj, vj+1) не буде правим. Важливо, що між цими опорними ребрами знизу не буде інших рефлексних точок цього полігона, так як бралась найнижча. Отже, можна впевнено провести горизонтальну хорду H з r до (vi-1, vi) та (vj, vj+1) та відсікти оброблену частину. Для цього, в полігоні P, що представляється двозв’язним списком вершин, треба від’єднати частину від vi до vj за час O(1) та з’єднати vi+1 з v=H∩(vi-1, vi), w=H∩(vj, vj+1), та vj-1. Відкинувши оброблену частину P, також треба прибрати з поточного рефлексного двозв’язаного списку вершину r, чотири нерефлексивні вершини, та додати між рефлексійними сусідами r1 та r2 дві вершини, а саме v та w. І нарешті, для побудови графа R, додаємо до R вершину r, та якщо вказівники на рефлексні вершини R вершин vk та vm були ненульовими, проводимо донизу до них ребра з r. Для майбутньої добудови R, для v та w додається вказівник на вершину r. 
2) Якщо r має два суміжні ребра вище, тоді для кожної пари нерефлексивних вершин vi, vj рефлексійного двозв’язаного списку якому належить r, кожна по черзі пересувається полігоном P vi - в сторону до лівішої від неї рефлексивної вершини, та vj - до правішої. Це пересування відбувається до тих пір, доки ребро (vi, vi-1) та аналогічно (vj, vj+1), не перетне горизонтальну пряму з r. Тоді, якщо точка r знаходиться якраз між (vi, vi-1) та (vj, vj+1), проводимо горизонтальну хорду H з r до них, інакше продовжуємо такі проходи для інших нерефлексійних пар. Таким чином проведена хорда дійсно буде коректною, так як r - найнижча рефлексійна вершина поточного полігона P. Отже, залишається лише розбити полігон та двозв’язаний список на дві утворені частини, добудувавши при цьому граф R. Для цього, в полігоні P треба від’єднати частину від vi до vj за час O(1), додавши зліва v=H∩(vi-1, vi), замкнувши з r отримуючи лівий полігон, та аналогічно - додавши справа w=H∩(vj, vj+1), замкнувши з r отримуючи правий полігон. Тепер, до ненульових вказівників на вершину R для vi та vj, проводяться ребра донизу з
r до кожної. Для майбутньої побудови, для кожної нерефлексійної пари v, r та r, w нових циклічних двозв’язних списків, вказівник на вершину з R змінюється на r. 
З новим P та рефлексійним двозв’язаним списком, далі можна продовжувати побудову R рекурсивно, так як інваріанти зберігаються. 
Отже, наведений вище алгоритм будує граф R знизу вверх, проходячи від найменьших до найвищих рефлексійних вершин, проходячи двома вказівниками наверх по полігону, доки не знайдуться праве та ліве опорні ребра горизонтальної хорди, оброблена частина відсікається, та обробка продовжується рекурсивно. Маємо наступну теорему: 
Теорема. Часова складність полігональної триангуляції в запропонованому алгоритмі складає r log r + O(N), де r - кількість точок рефлексій полігона P. Сталий множник перед N log N не перевищує ½. 
Доведення. Так як одноразове сортування рефлексних вершин по y-координаті вимагає рівно r log r операцій та кожне ребро P при проході нерефлексивними вказівниками перевіряється один раз, проводячи нових горизонтальних до 2r ребер, маємо час обходу для побудови R рівний O(N + r) = O(N), nак як r <= N/2. Також, очевидно, r log r +O(N) <= ½ N log N +O(N), отже дійсно, сталий множник перед N log N не перевищує ½. 
3 Висновки 
В цій роботі було зроблено детальний розбір існуючих алгоритмів полігональної триангуляції, та запропоновано простий алгоритм, що працює за час r log r + O(N) та потенційно може спростити найшвидший лінійний детермінований алгоритм, якщо правильно використати запропоновані ідеї та твердження. Також, алгоритм був запрограмований та триангуляція - перевірена на полігонах різних типів та розмірів, підтверджуючи теоретичні результати. 
Таким чином, пророблена теоретична та практична частина є кроком до вирішення задачі спрощення та пришвидшення лінійного детермінованого алгоритму, та надає подальші напрями розвитку. Майбутні роботи мають спробувати використати ідею побудови карти горизонтальних хорд виключно із точок рефлексій простого полігона, та створити механізм балансування, що спростить кроки відновлення конформальності та грануляції, і зведе алгоритм до простої фази вверх та вниз, що складатимуться виключно із побудови “ray-shooting oracle” на кожному рівні та використання його для з’єднання карт хорд. Таким чином, найкращий алгоритм полігональної триангуляції може бути значно покращений. 
Список літератури 
1. Chazelle, B. (1991). Triangulating a simple polygon in linear time. Discrete & Computational Geometry, 6(5), 485–524. 2. ElGindy, H., Everett, H., & Toussaint, G. T. (1985). Slicing ear using transforms. Pattern Recognition Letters, 2(2), 77–82. 3. Garey, M. R., Johnson, D. S., Preparata, F. P., & Tarjan, R. E. (1978). Triangulating a simple polygon. Information Processing Letters, 7(4), 175–179. 
4. de Berg, M., van Kreveld, M., Overmars, M., & Schwarzkopf, O. (2000). Computational geometry: Algorithms and applications (2nd ed.). Springer. 
5. B. Chazelle and J. Incerpi, "Triangulation and shape-complexity," ACM Transactions on Graphics, vol. 3, no. 2. 135–152 6. Hertel, S., & Mehlhorn, K. (1985). Fast triangulation of the plane with respect to simple polygons. Information and Control, 64(1–3), 52–76. 
7. Tarjan, R. E., & van Wyk, C. J. (1988). An O(n log log n)-time algorithm for triangulating a simple polygon. SIAM Journal on Computing, 17(1), 143–178. 
8. Kirkpatrick, D. G., Klawe, M. M., & Tarjan, R. E. (1991). Polygon triangulation in O(n log log n) time with simple data structures (Technical Report No. CS-TR-327-91). Princeton University, Department of Computer Science. 9. Clarkson, K. L., Tarjan, R. E., & van Wyk, C. J. (1991). A fast Las Vegas algorithm for triangulating a simple polygon. In A. Sherman (Ed.), Proceedings of the 12th Annual Symposium on Computational Geometry. ACM. 423-432. 10. Seidel, R. (1991). A simple and fast incremental randomized algorithm for computing trapezoidal decompositions and for triangulating polygons. Computational Geometry: Theory and Applications, 1(1), 51–64. 
11. Amato, N. M., Goodrich, M. T., & Ramos, E. A. (2000). Linear-time triangulation of a simple polygon made easier via randomization. In Proceedings of the sixteenth annual symposium on Computational geometry. ACM. 201–212. 12. D. T. Lee and F. P. Preparata, Location of a point in a planar subdivision and its applications. SIAM Journal on Computing, vol. 6 (1977), 594-606. 
13. Edelsbrunner, H., Guibas, L. J., & Stolfi, J. (1984, October 25). Optimal point location in a monotone subdivision (Tech. Rep.). Systems Research Center, Digital Equipment Corporation. 5-6.